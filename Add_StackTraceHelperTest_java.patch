Index: src/main/java/io/github/cruisoring/Revokable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/io/github/cruisoring/Revokable.java	(date 1556461151000)
+++ src/main/java/io/github/cruisoring/Revokable.java	(date 1556538715689)
@@ -73,7 +73,7 @@
         checkWithoutNull(setter);
 
         timeStamp = System.currentTimeMillis();
-        StackTraceElement stack = StackTraceHelper.getCallerStackTrace(null, getCallerStackTraceKey);
+        StackTraceElement stack = StackTraceHelper.getCallerStackByEntry(null, getCallerStackTraceKey);
         label = StringHelper.tryFormatString("%s(%s:%d)",
             stack.getMethodName(), stack.getFileName(), stack.getLineNumber());
 
@@ -91,7 +91,7 @@
 
         timeStamp = System.currentTimeMillis();
         old = null;
-        StackTraceElement stack = StackTraceHelper.getCallerStackTrace(null, getCallerStackTraceKey);
+        StackTraceElement stack = StackTraceHelper.getCallerStackByEntry(null, getCallerStackTraceKey);
         label = StringHelper.tryFormatString("%s(%s:%d)",
             stack.getMethodName(), stack.getFileName(), stack.getLineNumber());
         revoker = runnableThrowable;
Index: src/main/java/io/github/cruisoring/utility/StackTraceHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/io/github/cruisoring/utility/StackTraceHelper.java	(date 1556461151000)
+++ src/main/java/io/github/cruisoring/utility/StackTraceHelper.java	(date 1556539488919)
@@ -2,47 +2,47 @@
 
 import io.github.cruisoring.logger.ILogger;
 import io.github.cruisoring.logger.Logger;
+import io.github.cruisoring.tuple.Tuple;
 
 import java.util.Arrays;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 import java.util.stream.Collectors;
 
-import static io.github.cruisoring.Asserts.checkWithoutNull;
-
 public class StackTraceHelper {
 
     /**
      * Java JDK or Logger class names that shall be neglected and used as indicators to locate the customer class methods
      */
-    static final Set<String> defaultNegligibleClassNames = new HashSet<String>
-            (Arrays.asList(Logger.class.getName(), ILogger.class.getName(), "sun.reflect", "java.lang"));
+    static final String[] defaultFilters = new String[]{
+            Logger.class.getName(), ILogger.class.getName(),
+            StackTraceHelper.class.getName(), "sun.reflect.NativeMethodAccessorImpl", "java.lang.Thread"};
 
     /**
      * Retrieve relevant stack trace elements.
      *
      * @param maxCount Its abs() specify up to how many stack frames to be displayed, prefer high level if it is less than 0.
      * @param ex       Exception if available to get the captured stack trace.
+     * @param filters   keywords that shall be neglected.
      * @return List of stack trace elements
      */
-    public static List<StackTraceElement> getStackTrace(int maxCount, Exception ex) {
+    public static List<StackTraceElement> getFilteredStacks(int maxCount, Exception ex, String... filters) {
         if (maxCount == 0)
             return null;
 
+        Tuple<String> tuple = Tuple.setOf(filters.length == 0 ? defaultFilters : filters);
         StackTraceElement[] stacks = ex == null ? Thread.currentThread().getStackTrace() : ex.getStackTrace();
         int first = -1, last = -1;
         for (int i = 0; i < stacks.length; i++) {
             String className = stacks[i].getClassName();
             if (first == -1) {
-                if (!defaultNegligibleClassNames.contains(className)) {
+                if (!tuple.anyMatch(s -> className.equals(s))) {
                     first = i;
                 } else {
                     continue;
                 }
             }
             last = i;
-            if (defaultNegligibleClassNames.contains(className)) {
+            if (tuple.anyMatch(s -> className.equals(s))) {
                 break;
             }
         }
@@ -57,31 +57,59 @@
         return concerned;
     }
 
+    /**
+     * Get the caller class who calls any methods of the baseTestRunner
+     *
+     * @param filters keywords that shall be neglected.
+     * @return Class of the Caller.
+     */
+    public static List<String> getFilteredCallers(String... filters) {
+        List<StackTraceElement> stacks = getFilteredStacks(500, null, filters);
+        List<String> classNames = stacks.stream().map(stack -> stack.getClassName()).collect(Collectors.toList());
+
+        return classNames;
+    }
+
+    /**
+     * Get the caller class who calls any methods of the baseTestRunner
+     *
+     * @param filters keywords that shall be neglected.
+     * @return Class of the Caller.
+     */
+    public static Class getCallerClass(String... filters) {
+        List<String> callers = getFilteredCallers(filters);
+        try {
+            String className = callers.get(callers.size() - 1);
+            Class callerClass = Class.forName(className);
+            return callerClass;
+        } catch (Exception ex) {
+            return null;
+        }
+    }
+
     /**
      * Retrieve the StackTraceElement of the caller of the class/method as specified by the <code>keywords</code>
      *
      * @param ex       Used to get the captured stackTrace when Exception is thrown
-     * @param keywords the keywords of the called class/method to be used to
+     * @param entryKeywords the keywords of the called class/method to be used to
      * @return the last caller of the called class/method as specified by <code>keywords</code>
      */
-    public static StackTraceElement getCallerStackTrace(Exception ex, String... keywords) {
-        checkWithoutNull(keywords);
-
-        if(keywords.length==0){
-            keywords = new String[]{StackTraceHelper.class.getSimpleName() + ".java"};
+    public static StackTraceElement getCallerStackByEntry(Exception ex, String... entryKeywords) {
+        if (entryKeywords == null || entryKeywords.length == 0) {
+            entryKeywords = new String[]{StackTraceHelper.class.getSimpleName() + ".java"};
         }
         boolean notMatched = true;
         StackTraceElement[] stacks = ex == null ? Thread.currentThread().getStackTrace() : ex.getStackTrace();
         int length = stacks.length;
-        for (int i = 0; i < length; i++) {
+        for (int i = 1; i < length; i++) {
             StackTraceElement stack = stacks[i];
             String fileName = stack.getFileName();
             if (notMatched) {
-                if (StringHelper.containsAll(fileName, keywords)) {
+                if (StringHelper.containsAll(fileName, entryKeywords)) {
                     notMatched = false;
                 }
             } else {
-                if (!StringHelper.containsAll(fileName, keywords)) {
+                if (!StringHelper.containsAll(fileName, entryKeywords)) {
                     return stack;
                 }
             }
@@ -89,10 +117,18 @@
         return null;
     }
 
-    public static String getCallerLabel(Exception ex, String... keywords){
-        StackTraceElement stack = StackTraceHelper.getCallerStackTrace(null, keywords);
-        String label = StringHelper.tryFormatString("%s(%s:%d)",
+    /**
+     * Get the label to describe the caller.
+     * @param ex       Used to get the captured stackTrace when Exception is thrown
+     * @param keywords the keywords of the called class/method to be used to
+     * @return the label to describe the caller that is identified by the given keywords.
+     */
+    public static String getCallerLabel(Exception ex, String... keywords) {
+        StackTraceElement stack = getCallerStackByEntry(ex, keywords);
+        String label = stack == null ? null : StringHelper.tryFormatString("%s(%s:%d)",
                 stack.getMethodName(), stack.getFileName(), stack.getLineNumber());
         return label;
     }
+
+
 }
Index: src/main/java/io/github/cruisoring/logger/ILogger.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/io/github/cruisoring/logger/ILogger.java	(date 1556461151000)
+++ src/main/java/io/github/cruisoring/logger/ILogger.java	(date 1556537475081)
@@ -158,7 +158,7 @@
         if (maxCount == 0) {
             return "";
         }
-        List<StackTraceElement> stacks = StackTraceHelper.getStackTrace(maxCount, ex);
+        List<StackTraceElement> stacks = StackTraceHelper.getFilteredStacks(maxCount, ex);
         if (stacks == null) {
             return "";
         }
Index: src/main/java/io/github/cruisoring/utility/ResourceHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/io/github/cruisoring/utility/ResourceHelper.java	(date 1556461151000)
+++ src/main/java/io/github/cruisoring/utility/ResourceHelper.java	(date 1556539488913)
@@ -7,7 +7,9 @@
 import java.io.IOException;
 import java.net.URI;
 import java.net.URL;
+import java.nio.charset.Charset;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.*;
 
@@ -15,6 +17,50 @@
  * Helper class for resource retrieval.
  */
 public class ResourceHelper {
+    public final static String[] resourcePaths;
+    public static String MAVEN_TARGET_CLASSES = "target/classes/";
+    public static String MAVEN_TARGET_TEST_CLASSES = "target/test-classes/";
+    public static String MAVEN_MAIN_RESOURCES = "src/main/resources/";
+    public static String MAVEN_TEST_RESOURCES = "src/test/resources/";
+
+    static {
+        resourcePaths = getResourcePaths("sun.reflect", "java.lang");
+    }
+
+    /**
+     * Retrive the ORIGINAL resources folders of all modules involved with the call
+     *
+     * @param negligibles keywords that shall be neglected.
+     * @return String array identifying the absolute paths of related resource folders
+     */
+    private static String[] getResourcePaths(String... negligibles) {
+        List<String> classPaths = new ArrayList<>();
+        List<String> classNames = StackTraceHelper.getFilteredCallers(negligibles);
+        for (int i = 0; i < classNames.size(); i++) {
+            try {
+                String className = classNames.get(i);
+                Class clazz = Class.forName(className);
+                String classPath = clazz.getProtectionDomain().getCodeSource().getLocation().getPath();
+
+                if (classPath.endsWith(MAVEN_TARGET_CLASSES)) {
+                    classPath = classPath.replace(MAVEN_TARGET_CLASSES, MAVEN_MAIN_RESOURCES);
+                } else if (classPath.endsWith(MAVEN_TARGET_TEST_CLASSES)) {
+                    classPath = classPath.replace(MAVEN_TARGET_TEST_CLASSES, MAVEN_TEST_RESOURCES);
+                } else {
+                    continue;
+                }
+
+                if (!classPaths.contains(classPath)) {
+                    classPaths.add(classPath);
+                }
+            } catch (Exception ex) {
+                continue;
+            }
+        }
+        Collections.reverse(classPaths);
+        String[] result = classPaths.toArray(new String[0]);
+        return result;
+    }
 
     /**
      * Scans all classes accessible from the context class loader which belong to the given package and subpackages.
@@ -167,4 +213,102 @@
         }
         result.put(propertiesName, properties); //Let it throw Exception if there is duplicated keys.
     }
+
+    /**
+     * Retrieve the solic file from any possible module.
+     *
+     * @param filename    Name of the file to be handled.
+     * @param folderNames Directory names of the file.
+     * @return File instance if it exist, otherwise null.
+     */
+    public static File getResourceFile(String filename, String... folderNames) {
+        Objects.requireNonNull(filename);
+
+        String folderPath = folderNames == null ? "" : String.join("/", folderNames);
+
+        //Try to load properties if it is not loaded by previous resourcePaths.
+        for (String path : resourcePaths) {
+            File resourceFolder = new File(path, folderPath);
+            File file = new File(resourceFolder, filename);
+            //No such resources defined, continue
+            if (!file.exists()) {
+                continue;
+            }
+
+            return file;
+        }
+
+        return null;
+    }
+
+    /**
+     * Locate the resource identified with filename and its folder names from any possible module.
+     *
+     * @param filename    Name of the file to be handled.
+     * @param folderNames Directory names of the file.
+     * @return the absolute file path if it is found, or null when there is no such resource.
+     */
+    public static Path getResourcePath(String filename, String... folderNames) {
+        Objects.requireNonNull(filename);
+
+        String folderPath = folderNames == null ? "" : String.join("/", folderNames);
+
+        //Try to load properties if it is not loaded by previous resourcePaths.
+        for (String path : resourcePaths) {
+            File resourceFolder = new File(path, folderPath);
+            File file = new File(resourceFolder, filename);
+            //No such resources defined, continue
+            if (!file.exists()) {
+                continue;
+            }
+
+            return file.toPath();
+        }
+
+        String error = String.format("Failed to locate %s in folder of %s from %s", filename, folderPath, String.join(",", resourcePaths));
+        throw new RuntimeException(error);
+    }
+
+    /**
+     * Retrieve the absolute file path from any possible module.
+     *
+     * @param filename    Name of the file to be handled.
+     * @param folderNames Directory names of the file.
+     * @return Path of the expected file.
+     */
+    public static Path getAbsoluteFilePath(String filename, String... folderNames) {
+        Objects.requireNonNull(filename);
+
+        String folderPath = folderNames == null ? "" : String.join("/", folderNames);
+
+        //Output Folder in the original caller module target directory
+        File folder = new File(resourcePaths[0], folderPath);
+
+        File file = new File(folder, filename);
+        return file.toPath();
+    }
+
+    /**
+     * Retrieve the content of the resource file a String.
+     *
+     * @param resourceFilename The relative path of the reourcefile to be checked.
+     * @param folders          Optional folder names.
+     * @return NULL if there is no such resource identified by the relative path, or content of the resource as a String.
+     */
+    public static String getTextFromResourceFile(String resourceFilename, String... folders) {
+        Path path = getResourcePath(resourceFilename, folders);
+//        log.info(String.format("%s would be extracted from %s", resourceFilename, path));
+
+        if (path == null) {
+            return null;
+        }
+
+        try {
+            byte[] encoded = Files.readAllBytes(path);
+            String text = new String(encoded, Charset.defaultCharset());
+            return text;
+        } catch (IOException e) {
+            return null;
+        }
+    }
 }
\ No newline at end of file
Index: src/test/java/io/github/cruisoring/utility/ResourceHelperTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/io/github/cruisoring/utility/ResourceHelperTest.java	(date 1556461151000)
+++ src/test/java/io/github/cruisoring/utility/ResourceHelperTest.java	(date 1556539488905)
@@ -6,6 +6,14 @@
 
 public class ResourceHelperTest {
 
+    @Test
+    public void testResourcePaths() {
+        String[] resourcePaths = ResourceHelper.resourcePaths;
+        assertTrue(resourcePaths.length == 2,
+                resourcePaths[0].endsWith("src/test/resources/"),
+                resourcePaths[1].endsWith("src/main/resources/"));
+    }
+
     @Test
     public void isResourceAvailable() {
         assertTrue(ResourceHelper.isResourceAvailable("test.sql"));
